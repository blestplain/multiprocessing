'''
Created on Oct 25, 2016

apply context managers for lock
always release lock 

put results in a queue

use poison pill to indicate end of queue

@author: Jun
'''

from multiprocessing import Process, Pool, Event, Lock, Value
from multiprocessing.queues import Queue
import os

N = 2
task_que = Queue(5)
results_que = Queue(5)
no_more_task = Event()
global_lock = Lock()
results_lock = Lock()


class EndOfQueue(): # poison pill
    def __init__(self, pid):
        self.pid = pid


def calculator(x, y):
    s = 0
    print 'Computing:', x, y
    for i in range(x,y,1):
        s += 1
    print 'Local sum:', s
    return s        


def post_tasks():
    try:
        for i in range(0, 10000, 1000):
            print 'Posting task..'
            task_que.put((i, i+1000))
            print 'Posted task..{}'.format(i)
        print 'Finished posting tasks..'
    finally:
        no_more_task.set()

def process_task():
    while True:
        with global_lock:
            print 'PID {} aquired lock.'.format(os.getpid())
            if not task_que.empty(): 
                task = task_que.get()
            else:
                print 'No more task?', no_more_task.is_set()
                if no_more_task.is_set():
                    print 'PID {} finishes processing'.format(os.getpid())
                    results_que.put(EndOfQueue(os.getpid()))
                    return 0
                else:
                    continue
        print 'PID {}: Processing task'.format(os.getpid())
        s = calculator(task[0], task[1])
        results_que.put(s)
        print 'PID {}: Put new result {}'.format(os.getpid(), s)

def process_results():
    total = 0
    num_active_worker = N
    while num_active_worker > 0:
        if not results_que.empty():
            r = results_que.get(timeout=3)
            if isinstance(r, EndOfQueue):
                num_active_worker -= 1
                print 'Number of active workers:', num_active_worker
            else:
                total += r 
                print 'Current total:', total
    print 'Total:', total

def main():
    poster = Process(target=post_tasks)
    poster.start()
    print 'Posting started..'
    
    pool = Pool(processes=N)
    worker_res = []    
    for i in range(N):
        print 'Starting working process:', i
        worker_res.append(pool.apply_async(process_task))
    pool.close()
    
    # process results generated by workers
    results_processor = Process(target=process_results)
    results_processor.start()
    
    for worker in worker_res: # check worker returns, including exceptions
        worker.get()    
        
    results_processor.join()
    
if __name__ == '__main__':
    main() 
